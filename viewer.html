<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NeuroGuessr</title>
    <link rel="stylesheet" href="niivue.css" />
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@700&display=swap" rel="stylesheet">
    <style>
      .slider {
        width: 100px;
        margin: 0 10px;
      }
      .slider-label {
        color: white;
        font-size: 14px;
        margin-right: 5px;
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="logo-title-container">
        <img src="/neuroguessr_web/data/neuroguessr.png" alt="NeuroGuessr Logo" class="logo" />
        <h1 onclick="window.location.href='index.html'">NeuroGuessr</h1>
      </div>
      <div class="game-status">
        <p id="target-label"><span class="target-text">Target: Not Started</span></p>
        <div class="score-error-container">
          <p id="score-label">Correct: 0</p>
          <p id="error-label">Errors: 0</p>
          <p id="streak-label" style="display: none;">Streak: 0</p>
          <p id="time-label" style="display: none;">Time: 00:00</p>
        </div>
      </div>
      <div class="controls">
        <label class="slider-label" for="alphaSlider">Atlas Opacity</label>
        <input
          type="range"
          min="0"
          max="255"
          value="255"
          class="slider"
          id="alphaSlider"
        />
      </div>
      <div class="dropdown">
        <button class="dropbtn">
          View Options
          <span class="hamburger">
            <svg width="24" height="18" viewBox="0 0 24 18" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M0 1H24" stroke="white" stroke-width="1.5"/>
              <path d="M0 9H24" stroke="white" stroke-width="1.5"/>
              <path d="M0 17H24" stroke="white" stroke-width="1.5"/>
            </svg>
          </span>
        </button>
        <div class="dropdown-content">
          <a href="#" class="viewBtn" id="|Axial">Axial</a>
          <a class="viewBtn" id="|Sagittal">Sagittal</a>
          <a class="viewBtn" id="|Coronal">Coronal</a>
          <a class="viewBtn" id="|Render">Render</a>
          <a class="viewBtn" id="|MultiPlanar">A+C+S</a>
          <a class="viewBtn dropdown-item-checked" id="|MultiPlanarRender">A+C+S+R</a>
          <a class="viewBtn" id="Radiological">Radiological</a>
          <a class="viewBtn dropdown-item-checked" id="ColoredAtlas">Colored Atlas</a>
        </div>
      </div>
    </header>
    <main>
      <canvas id="gl1"></canvas>
      <script>
        const canvas = document.getElementById("gl1");

        function setCanvasSize() {
          const dpr = window.devicePixelRatio || 1;
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const mainElement = document.querySelector("main");
          const containerWidth = mainElement ? mainElement.clientWidth : viewportWidth;
          const canvasWidth = containerWidth;
          const canvasHeight = Math.min(viewportHeight * 0.5, viewportHeight - 100);
          canvas.width = canvasWidth * dpr;
          canvas.height = canvasHeight * dpr;
          canvas.style.width = `${canvasWidth}px`;
          canvas.style.height = `${canvasHeight}px`;
          if (window.nv1) {
            window.nv1.resizeListener();
            window.nv1.drawScene();
          }
        }

        setCanvasSize();
        window.addEventListener("resize", setCanvasSize);
        window.addEventListener("orientationchange", setCanvasSize);
      </script>
    </main>
    <div class="button-container">
      <button id="return-button" class="return-button">Return</button>
      <button id="guess-button" class="guess-button" disabled>Confirm Guess</button>
    </div>
    <script type="module" async>
      import * as niivue from "/neuroguessr_web/dist/index.js";

      let gameRunning = false;
      let score = 0;
      let errors = 0;
      let streak = 0;
      let currentTarget = null;
      let selectedVoxel = null;
      let validRegions = [];
      let cmap = null;
      let nv1 = null;
      let clut = null;
      let attempts = 0;
      let startTime = null;
      let timerInterval = null;
      let usedRegions = [];

      const guessButton = document.getElementById("guess-button");
      const returnButton = document.getElementById("return-button");
      const targetLabel = document.getElementById("target-label");
      const scoreLabel = document.getElementById("score-label");
      const errorLabel = document.getElementById("error-label");
      const streakLabel = document.getElementById("streak-label");
      const timeLabel = document.getElementById("time-label");
      const targetText = targetLabel.querySelector('.target-text');
      const alphaSlider = document.getElementById("alphaSlider");

      returnButton.addEventListener('click', () => {
        window.location.href = 'index.html';
      });

      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !guessButton.disabled && gameRunning && mode !== 'navigation') {
          e.preventDefault();
          validateGuess();
        }
      });

      alphaSlider.oninput = function () {
        nv1.setOpacity(1, this.value / 255);
        nv1.updateGLVolume();
      };

      const urlParams = new URLSearchParams(window.location.search);
      const atlas = urlParams.get('atlas') || 'aal';
      const mode = urlParams.get('mode') || 'practice';
      const atlasFiles = {
        'aal': { nii: '/neuroguessr_web/data/aal.nii.gz', json: '/neuroguessr_web/data/aal.json', name: 'AAL' },
        'harvard-oxford': { nii: '/neuroguessr_web/data/HarvardOxford-cort-maxprob-thr25-1mm.nii.gz', json: '/neuroguessr_web/data/harvard_oxford.json', name: 'Harvard-Oxford' },
        'brodmann': { nii: '/neuroguessr_web/data/brodmann_grid.nii.gz', json: '/neuroguessr_web/data/brodmann.json', name: 'Brodmann' },
        'glasser': { nii: '/neuroguessr_web/data/HCP-MMP1_on_MNI152_ICBM2009a_nlin_hd.nii.gz', json: '/neuroguessr_web/data/glasser_neuroparc.json', name: 'Glasser' },
        'destrieux': { nii: '/neuroguessr_web/data/Destrieux_space-MNI152NLin6_res-1x1x1.nii.gz', json: '/neuroguessr_web/data/destrieux.json', name: 'Destrieux' },
        'subcortical': { nii: '/neuroguessr_web/data/ICBM2009b_asym-SubCorSeg-1mm_nn_regrid.nii.gz', json: '/neuroguessr_web/data/subcortical.json', name: 'Subcortical' },
        'cerebellum': { nii: '/neuroguessr_web/data/Cerebellum-MNIfnirt-maxprob-thr25-1mm.nii.gz', json: '/neuroguessr_web/data/cerebellum.json', name: 'Cerebellum' },
        'xtract': { nii: '/neuroguessr_web/data/xtract_web.nii.gz', json: '/neuroguessr_web/data/xtract_labels.json', name: 'White Matter'},
        'thalamus': { nii: '/neuroguessr_web/data/Thalamus_web.nii.gz', json: '/neuroguessr_web/data/thalamus_labels.json', name: 'Thalamus'},
        'HippoAmyg': { nii: '/neuroguessr_web/data/HippoAmyg_web.nii.gz', json: '/neuroguessr_web/data/HippoAmyg_labels.json', name: 'Hippocampus & Amygdala' },
        'JHU': { nii: '/neuroguessr_web/data/JHU_web.nii.gz', json: '/neuroguessr_web/data/JHU_labels.json', name: 'JHU' },
      };

      const selectedAtlasFiles = atlasFiles[atlas] || atlasFiles['aal'];

      async function initNiivue() {
        try {
          nv1 = new niivue.Niivue({
            show3Dcrosshair: true,
            backColor: [0, 0, 0, 1],
            crosshairColor: [1, 1, 1, 1]
          });
          await nv1.attachTo("gl1");
          nv1.setInterpolation(true);
          nv1.opts.crosshairGap = 12;
          nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS;
          nv1.opts.dragMode = nv1.dragModes.slicer3D;
          nv1.opts.yoke3Dto2DZoom = true;

          const volumeList1 = [
            { url: '/neuroguessr_web/data/mni152.nii.gz' },
            { url: selectedAtlasFiles.nii, isApplyScaling: false }
          ];
          await nv1.loadVolumes(volumeList1);

          cmap = await fetchJSON(selectedAtlasFiles.json);
          nv1.volumes[1].setColormapLabel(cmap);
          clut = new Uint8Array(cmap.R.length * 4);

          if (atlas === 'aal') {
            clut[0] = cmap.R[0];
            clut[1] = cmap.G[0];
            clut[2] = cmap.B[0];
            clut[3] = 255;
            clut[4] = cmap.R[1];
            clut[5] = cmap.G[1];
            clut[6] = cmap.B[1];
            clut[7] = 255;
          } else if (atlas === 'glasser' || atlas === 'destrieux') {
            console.log('Glasser cmap.labels:', cmap.labels);
          } else {
            clut[0] = 0;
            clut[1] = 0;
            clut[2] = 0;
            clut[3] = 0;
            clut[4] = cmap.R[1];
            clut[5] = cmap.G[1];
            clut[6] = cmap.B[1];
            clut[7] = 255;
          }

          for (let i = 2; i < cmap.R.length; i++) {
            clut[i * 4 + 0] = cmap.R[i];
            clut[i * 4 + 1] = cmap.G[i];
            clut[i * 4 + 2] = cmap.B[i];
            clut[i * 4 + 3] = 255;
          }
          nv1.volumes[1].colormapLabel.lut = clut.slice();
          nv1.setOpacity(1, 0.6);
          nv1.updateGLVolume();

          const atlasData = await nv1.volumes[1].getVolumeData();
          // Round floating-point values to integers and ensure uniqueness
          const dataRegions = [...new Set(atlasData.filter(val => val > 0).map(val => Math.round(val)))];
          // Filter regions to only those with valid labels
          validRegions = dataRegions.filter(val => cmap.labels[val] !== undefined && Number.isInteger(val));

          console.log(`Atlas: ${selectedAtlasFiles.name}`);
          console.log(`Atlas Data Sample:`, atlasData.slice(0, 10));
          console.log(`Data Regions (rounded):`, dataRegions);
          console.log(`Valid Regions:`, validRegions);
          console.log(`Valid Region Labels:`, validRegions.map(id => cmap.labels[id]));

          if (validRegions.length === 0) {
            console.error(`No valid regions found in ${selectedAtlasFiles.name} data.`);
            console.log(`cmap.labels keys:`, Object.keys(cmap.labels));
            validRegions = Object.keys(cmap.labels)
              .map(Number)
              .filter(val => val > 0 && Number.isInteger(val));
            if (validRegions.length === 0) {
              throw new Error(`No valid regions available for ${selectedAtlasFiles.name}`);
            }
            console.warn(`Fallback to cmap.labels keys:`, validRegions);
          }

          nv1.setClipPlane([2, 270, 0]);
          nv1.opts.isSliceMM = true;

          setupViewMenu();
          startGame();
        } catch (error) {
          console.error(`Failed to initialize Niivue for ${selectedAtlasFiles.name}:`, error);
          targetText.textContent = `Error: Failed to load ${selectedAtlasFiles.name} data`;
        }
      }

      async function fetchJSON(fnm) {
        try {
          const response = await fetch(fnm);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          return await response.json();
        } catch (e) {
          console.error(`Fetch failed for ${fnm}:`, e);
          throw new Error(`${e.message}`);
        }
      }

      function toggleGroup(id) {
        let buttons = document.getElementsByClassName("viewBtn");
        let char0 = id.charAt(0);
        for (let i = 0; i < buttons.length; i++) {
          if (buttons[i].id.charAt(0) !== char0) continue;
          buttons[i].classList.remove("dropdown-item-checked");
          if (buttons[i].id === id)
            buttons[i].classList.add("dropdown-item-checked");
        }
      }

      function setupViewMenu() {
        async function onViewButtonClick(event) {
          event.preventDefault();
          if (event.target.id.charAt(0) === "|") {
            if (event.target.id === "|Axial") nv1.setSliceType(nv1.sliceTypeAxial);
            if (event.target.id === "|Coronal") nv1.setSliceType(nv1.sliceTypeCoronal);
            if (event.target.id === "|Sagittal") nv1.setSliceType(nv1.sliceTypeSagittal);
            if (event.target.id === "|Render") {
              nv1.setSliceType(nv1.sliceTypeRender);
              nv1.setClipPlane([2, 270, 0]);
            }
            if (event.target.id === "|MultiPlanar") {
              nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.NEVER;
              nv1.setSliceType(nv1.sliceTypeMultiplanar);
            }
            if (event.target.id === "|MultiPlanarRender") {
              nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS;
              nv1.setSliceType(nv1.sliceTypeMultiplanar);
            }
            toggleGroup(event.target.id);
          }
          if (event.target.id === "Radiological") {
            nv1.opts.isRadiologicalConvention = !nv1.opts.isRadiologicalConvention;
            event.srcElement.classList.toggle("dropdown-item-checked");
            nv1.drawScene();
            return;
          }
          if (event.target.id === "ColoredAtlas") {
            const isChecked = event.srcElement.classList.contains("dropdown-item-checked");
            nv1.setOpacity(1, isChecked ? 0.0 : alphaSlider.value / 255);
            event.srcElement.classList.toggle("dropdown-item-checked");
            nv1.updateGLVolume();
            return;
          }
        }

        var buttons = document.getElementsByClassName("viewBtn");
        for (let i = 0; i < buttons.length; i++)
          buttons[i].addEventListener("click", onViewButtonClick, false);
      }

      function highlightTarget(isSuccess) {
        targetText.style.transition = 'all 0.1s ease-in-out';
        targetText.style.color = isSuccess ? '#4ade80' : '#f87171';
        targetText.style.fontWeight = 'bold';
        targetText.style.fontSize = '3rem';
        setTimeout(() => {
          targetText.style.color = '#d9dddc';
          targetText.style.fontWeight = '500';
          targetText.style.fontSize = '3rem';
          setTimeout(() => {
            targetText.style.transition = '';
          }, 100);
        }, 200);
      }

      function resetGameState() {
        currentTarget = null;
        selectedVoxel = null;
        attempts = 0;
        usedRegions = [];
        targetText.textContent = mode === 'navigation' ? "Click to identify a region" : "Target: Not Started";
        targetText.style.color = '#d9dddc';
        targetText.style.fontWeight = '500';
        targetText.style.fontSize = '3rem';
        targetText.style.transition = '';
        guessButton.disabled = true;
        if (clut && nv1) {
          nv1.volumes[1].colormapLabel.lut = clut.slice();
          nv1.updateGLVolume();
        }
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      function selectNewTarget() {
        if (validRegions.length === 0) {
          resetGameState();
          return;
        }
        if (mode === 'time-attack' && usedRegions.length === validRegions.length) {
          endTimeAttack();
          return;
        }
        let availableRegions = mode === 'time-attack' 
          ? validRegions.filter(r => !usedRegions.includes(r))
          : validRegions;
        if (availableRegions.length === 0) {
          resetGameState();
          return;
        }
        currentTarget = availableRegions[Math.floor(Math.random() * availableRegions.length)];
        if (mode === 'time-attack') {
          usedRegions.push(currentTarget);
        }
        targetText.textContent = `Find: ${cmap.labels[currentTarget] || "Unknown"}`;
        targetText.style.color = '#d9dddc';
        targetText.style.fontWeight = '500';
        targetText.style.fontSize = '3rem';
        targetText.style.transition = '';
        guessButton.disabled = true;
        attempts = 0;
        if (clut && nv1) {
          nv1.volumes[1].colormapLabel.lut = clut.slice();
          nv1.updateGLVolume();
        }
      }

      function highlightRegionFluorescentYellow(regionId) {
        console.log('highlightRegionFluorescentYellow called with regionId:', regionId);
        if (clut && nv1 && regionId * 4 < clut.length) {
          const lut = clut.slice();
          for (let i = 3; i < lut.length; i += 4) {
            lut[i] = 0;
          }
          lut[regionId * 4 + 0] = 255;
          lut[regionId * 4 + 1] = 255;
          lut[regionId * 4 + 2] = 0;
          lut[regionId * 4 + 3] = 255;
          nv1.volumes[1].colormapLabel.lut = lut;
          nv1.updateGLVolume();
          nv1.drawScene();
        } else {
          console.error('Cannot highlight region:', {
            clut: !!clut,
            nv1: !!nv1,
            regionId,
            lutLength: clut?.length
          });
        }
      }

      function startTimer() {
        startTime = Date.now();
        timeLabel.style.display = 'block';
        timerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
          const seconds = (elapsed % 60).toString().padStart(2, '0');
          timeLabel.textContent = `Time: ${minutes}:${seconds}`;
        }, 1000);
      }

      function endTimeAttack() {
        clearInterval(timerInterval);
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const accuracy = ((score / (score + errors)) * 100).toFixed(2);
        targetText.textContent = `Game Over! Accuracy: ${accuracy}%, Time: ${Math.floor(elapsed / 60)}m ${elapsed % 60}s`;
        highlightTarget(true);
        setTimeout(() => {
          window.location.href = `index.html?score=${accuracy}&time=${elapsed}`;
        }, 2000);
      }

      function startGame() {
        gameRunning = true;
        score = 0;
        errors = 0;
        streak = 0;
        scoreLabel.textContent = "Correct: 0";
        errorLabel.textContent = "Errors: 0";
        streakLabel.textContent = "Streak: 0";
        timeLabel.textContent = "Time: 30:00";
        streakLabel.style.display = mode === 'streak' ? 'block' : 'none';
        timeLabel.style.display = mode === 'time-attack' ? 'block' : 'none';
        guessButton.style.display = mode === 'navigation' ? 'none' : 'inline-block';
        scoreLabel.style.display = mode === 'navigation' ? 'none' : 'block';
        errorLabel.style.display = mode === 'navigation' ? 'none' : 'block';
        if (mode === 'time-attack') {
          startTimer();
        }
        if (mode === 'navigation') {
          targetText.textContent = "Click to identify a region";
        } else {
          selectNewTarget();
        }
      }

      function validateGuess() {
        if (!selectedVoxel || !gameRunning || !currentTarget) {
          return;
        }
        const clickedRegion = nv1.volumes[1].getValue(selectedVoxel[0], selectedVoxel[1], selectedVoxel[2]);
        const targetName = cmap.labels[currentTarget] || `Region ${currentTarget} (Unknown)`;

        if (clickedRegion === currentTarget) {
          score++;
          scoreLabel.textContent = `Correct: ${score}`;
          streak = mode === 'streak' ? streak + 1 : streak;
          streakLabel.textContent = `Streak: ${streak}`;
          highlightTarget(true);
          attempts = 0;
          if (clut && nv1) {
            nv1.volumes[1].colormapLabel.lut = clut.slice();
            nv1.updateGLVolume();
          }
          selectNewTarget();
        } else {
          errors++;
          errorLabel.textContent = `Errors: ${errors}`;
          if (mode === 'practice') {
            attempts++;
            const incorrectRegionName = cmap.labels[clickedRegion] || `Region ${clickedRegion} (Unknown)`;
            targetText.textContent = `It's ${incorrectRegionName}, find ${targetName}!`;
            if (attempts >= 3) {
              highlightRegionFluorescentYellow(currentTarget);
            }
            // Revert to "Find: [region]" after 2 seconds
            setTimeout(() => {
              targetText.textContent = `Find: ${cmap.labels[currentTarget] || "Unknown"}`;
              targetText.style.color = '#d9dddc';
              targetText.style.fontWeight = '500';
              targetText.style.fontSize = '3rem';
              targetText.style.transition = '';
            }, 2000);
          }
          highlightTarget(false);
          if (mode === 'streak') {
            targetText.textContent = `Streak Ended! You got ${streak} in a row.`;
            highlightTarget(false);
            setTimeout(() => {
              window.location.href = `index.html?score=${streak}`;
            }, 1000);
            return;
          }
          selectedVoxel = null;
          guessButton.disabled = true;
        }
      }
      document.getElementById("gl1").addEventListener("click", (e) => {
        if (!gameRunning || !nv1) return;
        const pos = nv1.getNoPaddingNoBorderCanvasRelativeMousePosition(e, nv1.gl.canvas);
        const frac = nv1.canvasPos2frac([pos.x * nv1.uiData.dpr, pos.y * nv1.uiData.dpr]);
        if (frac[0] >= 0) {
          const mm = nv1.frac2mm(frac);
          const vox = nv1.volumes[1].mm2vox(mm);
          const idx = Math.round(nv1.volumes[1].getValue(vox[0], vox[1], vox[2]));
          if (isFinite(idx) && idx in cmap.labels) {
            selectedVoxel = vox;
            if (mode === 'navigation') {
              targetText.textContent = `Region: ${cmap.labels[idx] || "Unknown"}`;
              highlightRegionFluorescentYellow(idx);
              nv1.opts.crosshairColor = [1, 1, 1, 1];
              nv1.drawScene();
            } else {
              guessButton.disabled = false;
              nv1.opts.crosshairColor = [1, 1, 1, 1];
              nv1.drawScene();
            }
            console.log(`Clicked voxel: ${vox}, Region ID: ${idx}, Region Name: ${cmap.labels[idx] || "Unknown"}`);
          } else {
            selectedVoxel = null;
            if (mode === 'navigation') {
              targetText.textContent = "No region selected";
              if (clut && nv1) {
                nv1.volumes[1].colormapLabel.lut = clut.slice();
                nv1.updateGLVolume();
              }
            } else {
              guessButton.disabled = true;
            }
            console.log(`Clicked voxel: ${vox}, Invalid region ID: ${idx}`);
          }
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.code === 'Escape' && gameRunning && mode === 'navigation') {
          e.preventDefault();
          if (clut && nv1) {
            nv1.volumes[1].colormapLabel.lut = clut.slice();
            nv1.updateGLVolume();
            nv1.drawScene();
          }
          targetText.textContent = "Click to identify a region";
          selectedVoxel = null;
        }
      });

      guessButton.onclick = validateGuess;

      initNiivue();
    </script>
 </body>
</html>