<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NeuroTheka - AAL Region Viewer</title>
    <link rel="stylesheet" href="niivue.css" />
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@700&display=swap" rel="stylesheet">
  </head>
  <body>
    <header>
      <div class="header-container">
        <!-- Left: NeuroTheka and Current Region -->
        <div class="logo-title-container">
          <h1 onclick="window.location.href='index.html'">NeuroTheka</h1>
          <p id="target-label"><span class="target-text">Region: Loading...</span></p>
        </div>
        <!-- Center: Search Bar -->
        <div class="search-container">
          <input
            type="text"
            id="atlas-search"
            placeholder="Search regions (e.g., Amygdala, Frontal Pole...)"
            class="search-input"
          />
          <div id="search-suggestions" class="search-suggestions"></div>
        </div>
        <!-- Right: Dropdown Menu -->
        <div class="dropdown">
          <button class="dropbtn">
            View Options
            <span class="hamburger">
              <svg width="24" height="18" viewBox="0 0 24 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M0 1H24" stroke="white" stroke-width="1.5"/>
                <path d="M0 9H24" stroke="white" stroke-width="1.5"/>
                <path d="M0 17H24" stroke="white" stroke-width="1.5"/>
              </svg>
            </span>
          </button>
          <div class="dropdown-content">
            <a href="#" class="viewBtn" id="|Axial">Axial</a>
            <a class="viewBtn" id="|Sagittal">Sagittal</a>
            <a class="viewBtn" id="|Coronal">Coronal</a>
            <a class="viewBtn" id="|Render">Render</a>
            <a class="viewBtn" id="|MultiPlanar">A+C+S</a>
            <a class="viewBtn dropdown-item-checked" id="|MultiPlanarRender">A+C+S+R</a>
            <a class="viewBtn dropdown-item-checked" id="Radiological">Radiological</a>
            <a class="viewBtn dropdown-item-checked" id="ColoredAtlas">Colored Atlas</a>
            <div class="slider-container">
              <label class="slider-label" for="alphaSlider">Atlas Opacity</label>
              <input
                type="range"
                min="0"
                max="255"
                value="255"
                class="slider"
                id="alphaSlider"
              />
            </div>
          </div>
        </div>
      </div>
    </header>
    <main>
      <canvas id="gl1"></canvas>
    </main>
    <div class="button-container">
      <button id="return-button" class="return-button">Return</button>
    </div>
    <script type="module" async>
      import * as niivue from "/neuroguessr_web/dist/index.js";

      const returnButton = document.getElementById("return-button");
      const targetLabel = document.getElementById("target-label");
      const targetText = targetLabel.querySelector('.target-text');
      const alphaSlider = document.getElementById("alphaSlider");
      const searchInput = document.getElementById("atlas-search");
      const searchSuggestions = document.getElementById("search-suggestions");

      let nv1 = null;
      let cmap = null;
      let clut = null;
      let validRegions = [];
      let atlasRegions = [];
      let currentAtlas = null;
      let currentRegionId = null;

      // Atlas configuration
      const atlasFiles = {
        'aal': { nii: '/neuroguessr_web/data/aal.nii.gz', json: '/neuroguessr_web/data/aal.json', name: 'AAL' },
        'harvard-oxford': { nii: '/neuroguessr_web/data/HarvardOxford-cort-maxprob-thr25-1mm.nii.gz', json: '/neuroguessr_web/data/harvard_oxford.json', name: 'Harvard-Oxford' },
        'tissues': { nii: '/neuroguessr_web/data/Tissue_space-MNI152NLin6_res-1x1x1.nii.gz', json: '/neuroguessr_web/data/tissue.json', name: 'Tissue' },
        'hemisphere': { nii: '/neuroguessr_web/data/Hemispheric_space-MNI152NLin6_res-1x1x1.nii.gz', json: '/neuroguessr_web/data/hemisphere.json', name: 'Hemisphere' },
        'brodmann': { nii: '/neuroguessr_web/data/brodmann_grid.nii.gz', json: '/neuroguessr_web/data/brodmann.json', name: 'Brodmann' },
        'glasser': { nii: '/neuroguessr_web/data/HCP-MMP1_on_MNI152_ICBM2009a_nlin_hd.nii.gz', json: '/neuroguessr_web/data/glasser_neuroparc.json', name: 'Glasser' },
        'destrieux': { nii: '/neuroguessr_web/data/Destrieux_space-MNI152NLin6_res-1x1x1.nii.gz', json: '/neuroguessr_web/data/destrieux.json', name: 'Destrieux' },
        'schaefer': { nii: '/neuroguessr_web/data/Schaefer2018_100Parcels_7Networks_order_FSLMNI152_1mm.nii.gz', json: '/neuroguessr_web/data/schaefer100.json', name: 'Schaefer' },
        'yeo7': { nii: '/neuroguessr_web/data/Yeo-7-liberal_space-MNI152NLin6_res-1x1x1.nii.gz', json: '/neuroguessr_web/data/yeo7.json', name: 'Yeo7' },
        'yeo17': { nii: '/neuroguessr_web/data/Yeo-17-liberal_space-MNI152NLin6_res-1x1x1.nii.gz', json: '/neuroguessr_web/data/yeo17.json', name: 'Yeo17' },
        'subcortical': { nii: '/neuroguessr_web/data/ICBM2009b_asym-SubCorSeg-1mm_nn_regrid.nii.gz', json: '/neuroguessr_web/data/subcortical.json', name: 'Subcortical' },
        'cerebellum': { nii: '/neuroguessr_web/data/Cerebellum-MNIfnirt-maxprob-thr25-1mm.nii.gz', json: '/neuroguessr_web/data/cerebellum.json', name: 'Cerebellum' },
        'xtract': { nii: '/neuroguessr_web/data/xtract_web.nii.gz', json: '/neuroguessr_web/data/xtract_labels.json', name: 'White Matter' },
        'thalamus': { nii: '/neuroguessr_web/data/Thalamus_web.nii.gz', json: '/neuroguessr_web/data/thalamus_labels.json', name: 'Thalamus' },
        'HippoAmyg': { nii: '/neuroguessr_web/data/HippoAmyg_web.nii.gz', json: '/neuroguessr_web/data/HippoAmyg_labels.json', name: 'Hippocampus & Amygdala' },
        'JHU': { nii: '/neuroguessr_web/data/JHU_web.nii.gz', json: '/neuroguessr_web/data/JHU_labels.json', name: 'JHU' },
        'territories': { nii: '/neuroguessr_web/data/ArterialAtlas_round.nii.gz', json: '/neuroguessr_web/data/artery_territories.json', name: 'Territories' }
      };

      returnButton.addEventListener('click', () => {
        window.location.href = 'index.html';
      });

      alphaSlider.oninput = function () {
        if (nv1 && nv1.volumes.length > 1) {
          nv1.setOpacity(1, this.value / 255);
          nv1.updateGLVolume();
        }
      };

      const urlParams = new URLSearchParams(window.location.search);
      currentRegionId = parseInt(urlParams.get('region'), 10);
      currentAtlas = urlParams.get('atlas') || 'aal';

      let selectedAtlasFiles = atlasFiles[currentAtlas] || atlasFiles['aal'];

      async function fetchJSON(fnm) {
        try {
          const response = await fetch(fnm);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          return await response.json();
        } catch (e) {
          console.error(`Fetch failed for ${fnm}:`, e);
          throw new Error(`${e.message}`);
        }
      }

      function toggleGroup(id) {
        let buttons = document.getElementsByClassName("viewBtn");
        let char0 = id.charAt(0);
        for (let i = 0; i < buttons.length; i++) {
          if (buttons[i].id.charAt(0) !== char0) continue;
          buttons[i].classList.remove("dropdown-item-checked");
          if (buttons[i].id === id)
            buttons[i].classList.add("dropdown-item-checked");
        }
      }

      function setupViewMenu() {
        async function onViewButtonClick(event) {
          event.preventDefault();
          if (event.target.id.charAt(0) === "|") {
            if (event.target.id === "|Axial") nv1.setSliceType(nv1.sliceTypeAxial);
            if (event.target.id === "|Coronal") nv1.setSliceType(nv1.sliceTypeCoronal);
            if (event.target.id === "|Sagittal") nv1.setSliceType(nv1.sliceTypeSagittal);
            if (event.target.id === "|Render") {
              nv1.setSliceType(nv1.sliceTypeRender);
              nv1.setClipPlane(nv1.meshes.length > 0 ? [-0.1, 270, 0] : [2, 270, 0]);
            }
            if (event.target.id === "|MultiPlanar") {
              nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.NEVER;
              nv1.setSliceType(nv1.sliceTypeMultiplanar);
            }
            if (event.target.id === "|MultiPlanarRender") {
              nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS;
              nv1.setSliceType(nv1.sliceTypeMultiplanar);
            }
            toggleGroup(event.target.id);
          }
          if (event.target.id === "Radiological") {
            nv1.opts.isRadiologicalConvention = !nv1.opts.isRadiologicalConvention;
            event.srcElement.classList.toggle("dropdown-item-checked");
            nv1.drawScene();
            return;
          }
          if (event.target.id === "ColoredAtlas" && nv1.volumes.length > 1) {
            const isChecked = event.srcElement.classList.contains("dropdown-item-checked");
            nv1.setOpacity(1, isChecked ? 0.0 : alphaSlider.value / 255);
            event.srcElement.classList.toggle("dropdown-item-checked");
            nv1.updateGLVolume();
            return;
          }
        }

        var buttons = document.getElementsByClassName("viewBtn");
        for (let i = 0; i < buttons.length; i++)
          buttons[i].addEventListener("click", onViewButtonClick, false);
      }

      function highlightRegionFluorescentYellow(regionId) {
        if (clut && nv1 && nv1.volumes.length > 1 && regionId * 4 < clut.length) {
          const lut = new Uint8Array(clut.length);
          lut[regionId * 4 + 0] = 255; // R
          lut[regionId * 4 + 1] = 255; // G
          lut[regionId * 4 + 2] = 0;   // B
          lut[regionId * 4 + 3] = 255; // A
          nv1.volumes[1].colormapLabel.lut = lut;
          nv1.updateGLVolume();
          nv1.drawScene();
        } else {
          console.error('Cannot highlight region:', {
            clut: !!clut,
            nv1: !!nv1,
            volumes: nv1?.volumes?.length,
            regionId,
            lutLength: clut?.length
          });
        }
      }

      // Load labels for all atlases
      async function loadAtlasLabels() {
        atlasRegions = [];
        for (const [atlas, { json, name }] of Object.entries(atlasFiles)) {
          try {
            const response = await fetch(json);
            if (!response.ok) throw new Error(`HTTP ${response.status} for ${atlas}`);
            const labels = await response.json();
            const regions = Object.entries(labels.labels)
              .filter(([id]) => Number(id) > 0 && Number.isInteger(Number(id)))
              .map(([id, label]) => ({
                id: Number(id),
                name: label || `Region ${id}`,
                atlas,
                atlasName: name
              }));
            atlasRegions.push(...regions);
            console.log(`Loaded ${regions.length} regions for ${atlas} (${name})`);
          } catch (error) {
            console.error(`Failed to load labels for ${atlas}:`, error);
            targetText.textContent = `Error: Failed to load regions for ${name}`;
          }
        }
        console.log('Total regions loaded:', atlasRegions.length);
        if (atlasRegions.length === 0) {
          targetText.textContent = 'No atlas regions loaded. Search disabled.';
          searchInput.disabled = true;
        }
      }

      // Search across all atlas regions
      function searchAtlasRegions(query) {
        searchSuggestions.innerHTML = '';
        if (!query.trim()) {
          searchSuggestions.style.display = 'none';
          return;
        }
        const lowerQuery = query.toLowerCase();
        const matches = atlasRegions
          .filter(region => region.name.toLowerCase().includes(lowerQuery))
          .sort((a, b) => {
            const aIndex = a.name.toLowerCase().indexOf(lowerQuery);
            const bIndex = b.name.toLowerCase().indexOf(lowerQuery);
            if (aIndex !== bIndex) return aIndex - bIndex;
            return a.name.length - b.name.length;
          })
        if (matches.length === 0) {
          searchSuggestions.style.display = 'none';
          return;
        }
        matches.forEach(region => {
          const suggestion = document.createElement('div');
          suggestion.className = 'search-suggestion';
          suggestion.textContent = `${region.name} (${region.atlasName})`;
          suggestion.dataset.regionId = region.id;
          suggestion.dataset.atlas = region.atlas;
          suggestion.addEventListener('click', () => {
            console.log(`Selected region: ${region.name}, Atlas: ${region.atlas}, Region ID: ${region.id}`);
            updateVisualization(region.id, region.atlas);
            searchSuggestions.style.display = 'none';
            searchInput.value = '';
          });
          searchSuggestions.appendChild(suggestion);
        });
        searchSuggestions.style.display = 'block';
      }

      // Event listeners for search
      searchInput.addEventListener('input', () => {
        console.log('Search input:', searchInput.value);
        searchAtlasRegions(searchInput.value);
      });

      document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !searchSuggestions.contains(e.target)) {
          searchSuggestions.style.display = 'none';
        }
      });

      // Add scroll-to-cut plane functionality for xtract in 3D render mode with tractography
      function setupClipPlaneScroll() {
        const canvas = document.getElementById("gl1");
        canvas.addEventListener('wheel', (event) => {
          if (nv1.sliceType !== nv1.sliceTypeRender || nv1.meshes.length === 0) return;
          event.preventDefault();
          const delta = event.deltaY * 0.005;
          let clipPlane = nv1.scene.clipPlane || [-0.1, 270, 0];
          clipPlane[0] += delta;
          clipPlane[0] = Math.max(-1, Math.min(1, clipPlane[0]));
          nv1.setClipPlane(clipPlane);
          nv1.drawScene();
        });
      }

      async function updateVisualization(regionId, atlas) {
        try {
          currentRegionId = regionId;
          currentAtlas = atlas;
          selectedAtlasFiles = atlasFiles[currentAtlas] || atlasFiles['aal'];

          // Update URL without reloading
          const newUrl = `neurotheka.html?region=${regionId}&atlas=${atlas}`;
          history.pushState({}, '', newUrl);

          // Clear existing meshes
          nv1.meshes = [];
          nv1.updateGLVolume();

          // Load colormap
          cmap = await fetchJSON(selectedAtlasFiles.json);

          // Reset volumes
          nv1.volumes = [];
          let useTractography = false;
          let tractographyLoaded = false;

          if (currentAtlas === 'xtract' && isFinite(regionId) && regionId in cmap.labels) {
            // Check for tractography
            const tractLabel = cmap.labels[regionId].replace(/\s+/g, '_');
            const tractUrl = `/neuroguessr_web/data/TOM_trackings/${tractLabel}.tck`;
            try {
              // Test if tractography file exists by fetching headers
              const response = await fetch(tractUrl, { method: 'HEAD' });
              if (response.ok) {
                useTractography = true;
              }
            } catch (error) {
              console.log(`Tractography not available for ${tractLabel}:`, error);
            }
          }

          // Load volumes
          const volumeList = [{ url: '/neuroguessr_web/data/mni152.nii.gz' }];
          if (!useTractography) {
            volumeList.push({ url: selectedAtlasFiles.nii, isApplyScaling: false });
          }
          await nv1.loadVolumes(volumeList);

          if (useTractography) {
            // Load tractography
            const tractLabel = cmap.labels[regionId].replace(/\s+/g, '_');
            const tractUrl = `/neuroguessr_web/data/TOM_trackings/${tractLabel}.tck`;
            try {
              await nv1.loadMeshes([
                {
                  url: tractUrl,
                  rgba255: [0, 255, 255, 255],
                  fiberRadius: 0.2,
                  fiberColor: 'Global'
                }
              ]);
              nv1.setMeshProperty(nv1.meshes[0].id, 'colormap', 'blue');
              console.log(`Loaded tractography: ${tractUrl}`);
              tractographyLoaded = true;
              setupClipPlaneScroll();
            } catch (error) {
              console.error(`Failed to load tractography for ${tractLabel}:`, error);
              targetText.textContent = `Error: Failed to load tractography for ${cmap.labels[regionId]} (${selectedAtlasFiles.name})`;
              // Fallback to atlas volume
              await nv1.loadVolumes([{ url: selectedAtlasFiles.nii, isApplyScaling: false }]);
              useTractography = false;
            }
          }

          if (!useTractography && nv1.volumes.length > 1) {
            // Classic region highlighting for non-xtract or xtract without tractography
            nv1.volumes[1].setColormapLabel(cmap);
            const numRegions = Object.keys(cmap.labels).length;
            clut = new Uint8Array(numRegions * 4);
            for (let i = 0; i < numRegions; i++) {
              if (i === regionId && isFinite(regionId) && regionId in cmap.labels) {
                clut[i * 4 + 0] = 255; // R
                clut[i * 4 + 1] = 255; // G
                clut[i * 4 + 2] = 0;   // B
                clut[i * 4 + 3] = 255; // A
              } else {
                clut[i * 4 + 3] = 0; // Transparent
              }
            }
            nv1.volumes[1].colormapLabel.lut = clut.slice();
            nv1.setOpacity(1, 1.0);
            nv1.updateGLVolume();

            const atlasData = await nv1.volumes[1].getVolumeData();
            validRegions = [...new Set(atlasData.filter(val => val > 0).map(val => Math.round(val)))].filter(val => cmap.labels[val] !== undefined && Number.isInteger(val));

            if (validRegions.length === 0) {
              console.warn(`No valid regions found in ${selectedAtlasFiles.name} data.`);
              validRegions = Object.keys(cmap.labels)
                .map(Number)
                .filter(val => val > 0 && Number.isInteger(val));
              if (validRegions.length === 0) {
                targetText.textContent = `Warning: No valid regions for ${selectedAtlasFiles.name}`;
              }
            }
          }

          // Set initial clip plane
          nv1.setClipPlane(tractographyLoaded ? [-0.1, 270, 0] : [2, 270, 0]);
          nv1.opts.isSliceMM = true;

          // Update display
          if (isFinite(regionId) && regionId in cmap.labels) {
            targetText.textContent = `${cmap.labels[regionId] || "Unknown"} (${selectedAtlasFiles.name})`;
          } else {
            targetText.textContent = `Error: Invalid or unknown region (${selectedAtlasFiles.name})`;
            console.error(`Invalid region ID: ${regionId}`);
          }

          nv1.drawScene();
        } catch (error) {
          console.error(`Failed to update visualization for ${selectedAtlasFiles.name}:`, error);
          targetText.textContent = `Error: Failed to load ${selectedAtlasFiles.name} data`;
          if (nv1.volumes.length > 0) {
            nv1.drawScene(); // Render background if available
          }
        }
      }

      async function initNiivue() {
        try {
          nv1 = new niivue.Niivue({
            show3Dcrosshair: true,
            backColor: [0, 0, 0, 1],
            crosshairColor: [1, 1, 1, 1]
          });
          await nv1.attachTo("gl1");
          nv1.setInterpolation(true);
          nv1.opts.crosshairGap = 12;
          nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS;
          nv1.opts.dragMode = nv1.dragModes.slicer3D;
          nv1.opts.yoke3Dto2DZoom = true;
          nv1.opts.isRadiologicalConvention = true;

          setupViewMenu();
          await updateVisualization(currentRegionId, currentAtlas);
        } catch (error) {
          console.error(`Failed to initialize Niivue:`, error);
          targetText.textContent = `Error: Failed to initialize visualization`;
        }
      }

      // Initialize
      loadAtlasLabels().then(() => {
        initNiivue();
      });
    </script>
    <style>
      /* Header layout */
      .header-container {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        width: 100%;
        padding: 0.5rem 1rem;
        position: relative;
      }
      .logo-title-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: flex-start;
      }
      .logo-title-container h1 {
        margin: 0;
        cursor: pointer;
        text-align: left;
      }
      .logo-title-container #target-label {
        margin: 0.5rem 0 0 0;
        text-align: left;
      }
      .search-container {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        top: 0.5rem;
        width: 100%;
        max-width: 700px;
      }
      .search-input {
        width: 100%;
        box-sizing: border-box;
      }
      .search-suggestions {
        width: 100%;
        max-width: 700px;
        max-height: 450px;
      }
      .dropdown {
        align-self: flex-start;
      }
      #target-label .target-text {
        display: inline-block;
      }
      .dropbtn {
        font-size: 1.6875rem;
      }
      .dropdown-content a {
        font-size: 1.6875rem;
      }
      .slider-label {
        font-size: 0.875rem;
      }
    </style>
  <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93b0db3c9b387bdc',t:'MTc0NjQ1NDU5NC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>