<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title data-i18n="app_title">NeuroGuessr</title>
    <link rel="stylesheet" href="niivue.css" />
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@700&display=swap" rel="stylesheet">
  </head>
  <body>
    <header>
      <div class="header-container">
        <div class="logo-title-container">
          <img src="/neuroguessr_web/data/neuroguessr.png" alt="NeuroGuessr Logo" class="logo" />
          <h1 data-i18n="app_title" onclick="window.location.href='index.html'">NeuroGuessr</h1>
        </div>
        <div class="game-status">
          <p id="target-label"><span class="target-text" data-i18n="not_started">Target: Not Started</span></p>
          <div class="score-error-container">
            <p id="score-label" data-i18n="correct_label">Correct: 0</p>
            <p id="error-label" data-i18n="errors_label">Errors: 0</p>
            <p id="streak-label" style="display: none;" data-i18n="streak_label">Streak: 0</p>
            <p id="time-label" style="display: none;" data-i18n="time_label">Time: 00:00</p>
          </div>
        </div>
        <div class="header-controls-right">
          <div class="dropdown">
            <button class="dropbtn" data-i18n="view_options">
              View Options
              <span class="hamburger">
                <svg width="24" height="18" viewBox="0 0 24 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M0 1H24" stroke="white" stroke-width="1.5"/>
                  <path d="M0 9H24" stroke="white" stroke-width="1.5"/>
                  <path d="M0 17H24" stroke="white" stroke-width="1.5"/>
                </svg>
              </span>
            </button>
            <div class="dropdown-content">
              <a href="#" class="viewBtn" id="|Axial" data-i18n="axial">Axial</a>
              <a class="viewBtn" id="|Sagittal" data-i18n="sagittal">Sagittal</a>
              <a class="viewBtn" id="|Coronal" data-i18n="coronal">Coronal</a>
              <a class="viewBtn" id="|Render" data-i18n="render">Render</a>
              <a class="viewBtn" id="|MultiPlanar" data-i18n="multiplanar">A+C+S</a>
              <a class="viewBtn dropdown-item-checked" id="|MultiPlanarRender" data-i18n="multiplanar_render">A+C+S+R</a>
              <a class="viewBtn dropdown-item-checked" id="Radiological" data-i18n="radiological">Radiological</a>
              <a class="viewBtn dropdown-item-checked" id="ColoredAtlas" data-i18n="colored_atlas">Colored Atlas</a>
              <div class="slider-container">
                <label class="slider-label" for="alphaSlider" data-i18n="atlas_opacity">Atlas Opacity</label>
                <input
                  type="range"
                  min="0"
                  max="255"
                  value="255"
                  class="slider"
                  id="alphaSlider"
                />
              </div>
            </div>
          </div>
          <div class="language-switcher">
            <button class="lang-icon-btn" data-lang="fr" aria-label="FranÃ§ais">
              <img src="/neuroguessr_web/data/fr.png" alt="FR">
            </button>
            <button class="lang-icon-btn" data-lang="en" aria-label="English">
              <img src="/neuroguessr_web/data/en.png" alt="EN">
            </button>
          </div>
        </div>
      </div>
    </header>
    <main>
      <canvas id="gl1"></canvas>
      <script>
        const canvas = document.getElementById("gl1");

        function setCanvasSize() {
          const dpr = window.devicePixelRatio || 1;
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const mainElement = document.querySelector("main");
          const containerWidth = mainElement ? mainElement.clientWidth : viewportWidth;
          const canvasWidth = containerWidth;
          const canvasHeight = Math.min(viewportHeight * 0.5, viewportHeight - 100);
          canvas.width = canvasWidth * dpr;
          canvas.height = canvasHeight * dpr;
          canvas.style.width = `${canvasWidth}px`;
          canvas.style.height = `${canvasHeight}px`;
          if (window.nv1) {
            window.nv1.resizeListener();
            window.nv1.drawScene();
          }
        }

        setCanvasSize();
        window.addEventListener("resize", setCanvasSize);
        window.addEventListener("orientationchange", setCanvasSize);
      </script>
    </main>
    <div class="button-container">
      <button id="return-button" class="return-button" data-i18n="return_button">Return</button>
      <button id="restore-color-button" class="return-button" style="display: none;" data-i18n="restore_color">Restore Color (Esc)</button>
      <button id="guess-button" class="guess-button" disabled><span class="confirm-text" data-i18n="confirm_guess">CONFIRM GUESS</span><span class="space-text" data-i18n="space_key">(space)</span></button>
    </div>
    <script src="https://unpkg.com/i18next@23.15.1/dist/umd/i18next.min.js"></script>
    <script type="module" async>
      import * as niivue from "/neuroguessr_web/dist/index.js";

      // Initialize i18next
      i18next.init({
        lng: localStorage.getItem('language') || 'en',
        resources: {
          en: { translation: {} },
          fr: { translation: {} }
        }
      }, function(err, t) {
        updateContent();
      });

      // Load translation files
      Promise.all([
        fetch('/neuroguessr_web/data/i18n/en.json').then(res => res.json()),
        fetch('/neuroguessr_web/data/i18n/fr.json').then(res => res.json())
      ]).then(([en, fr]) => {
        i18next.addResourceBundle('en', 'translation', en);
        i18next.addResourceBundle('fr', 'translation', fr);
        updateContent();
      }).catch(err => {
        console.error('Failed to load translation files:', err);
      });

      function updateContent() {
        document.querySelectorAll('[data-i18n]').forEach(elem => {
          const key = elem.getAttribute('data-i18n');
          if (key.startsWith('[html]')) {
            elem.innerHTML = i18next.t(key.replace('[html]', ''));
          } else if (key.startsWith('[')) {
            const [attr, k] = key.match(/\[(.+)\](.+)/).slice(1);
            elem.setAttribute(attr, i18next.t(k));
          } else {
            elem.textContent = i18next.t(key);
          }
        });
      }

      // Language switcher
      document.querySelectorAll('.lang-icon-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const lang = btn.dataset.lang;
          i18next.changeLanguage(lang, () => {
            localStorage.setItem('language', lang);
            updateContent();
            // Reload atlas labels for the new language
            loadAtlasData().then(() => {
              if (gameRunning) {
                updateGameDisplay();
              }
            });
          });
        });
      });

      let gameRunning = false;
      let score = 0;
      let errors = 0;
      let streak = 0;
      let currentTarget = null;
      let selectedVoxel = null;
      let validRegions = [];
      let cmap = null;
      let nv1 = null;
      let clut = null;
      let attempts = 0;
      let startTime = null;
      let timerInterval = null;
      let usedRegions = [];
      let highlightedRegion = null;
      let tooltip = null;

      const guessButton = document.getElementById("guess-button");
      const returnButton = document.getElementById("return-button");
      const restoreColorButton = document.getElementById("restore-color-button");
      const targetLabel = document.getElementById("target-label");
      const scoreLabel = document.getElementById("score-label");
      const errorLabel = document.getElementById("error-label");
      const streakLabel = document.getElementById("streak-label");
      const timeLabel = document.getElementById("time-label");
      const targetText = targetLabel.querySelector('.target-text');
      const alphaSlider = document.getElementById("alphaSlider");

      returnButton.addEventListener('click', () => {
        window.location.href = 'index.html';
      });

      restoreColorButton.addEventListener('click', () => {
        if (gameRunning && mode === 'navigation') {
          if (clut && nv1) {
            nv1.volumes[1].colormapLabel.lut = clut.slice();
            nv1.updateGLVolume();
            nv1.drawScene();
          }
          targetText.textContent = i18next.t('click_to_identify');
          selectedVoxel = null;
          highlightedRegion = null;
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !guessButton.disabled && gameRunning && mode !== 'navigation') {
          e.preventDefault();
          validateGuess();
        }
      });

      alphaSlider.oninput = function () {
        nv1.setOpacity(1, this.value / 255);
        nv1.updateGLVolume();
      };

      const urlParams = new URLSearchParams(window.location.search);
      const atlas = urlParams.get('atlas') || 'aal';
      const mode = urlParams.get('mode') || 'practice';
      const atlasFiles = {
        'aal': { nii: '/neuroguessr_web/data/aal.nii.gz', json: '/neuroguessr_web/data/aal.json', json_fr: '/neuroguessr_web/data/aal_fr.json', name: 'AAL' },
        'harvard-oxford': { nii: '/neuroguessr_web/data/HarvardOxford-cort-maxprob-thr25-1mm.nii.gz', json: '/neuroguessr_web/data/harvard_oxford.json', json_fr: '/neuroguessr_web/data/harvard_oxford_fr.json', name: 'Harvard-Oxford' },
        'tissues': { nii: '/neuroguessr_web/data/mni152_pveseg.nii.gz', json: '/neuroguessr_web/data/tissue.json', json_fr: '/neuroguessr_web/data/tissue_fr.json', name: 'Tissue' },
        // 'hemisphere': { nii: '/neuroguessr_web/data/Hemispheric_space-MNI152NLin6_res-1x1x1.nii.gz', json: '/neuroguessr_web/data/hemisphere.json', json_fr: '/neuroguessr_web/data/hemisphere_fr.json', name: 'Hemisphere' },
        'brodmann': { nii: '/neuroguessr_web/data/brodmann_grid.nii.gz', json: '/neuroguessr_web/data/brodmann.json', json_fr: '/neuroguessr_web/data/brodmann_fr.json', name: 'Brodmann' },
        'glasser': { nii: '/neuroguessr_web/data/HCP-MMP1_on_MNI152_ICBM2009a_nlin_hd.nii.gz', json: '/neuroguessr_web/data/glasser_neuroparc.json', json_fr: '/neuroguessr_web/data/glasser_neuroparc_fr.json', name: 'Glasser' },
        'destrieux': { nii: '/neuroguessr_web/data/aparc.a2009s+aseg_stride.nii.gz', json: '/neuroguessr_web/data/destrieux_labs.json', json_fr: '/neuroguessr_web/data/destrieux_labs_fr.json', name: 'Destrieux' },
        'schaefer': { nii: '/neuroguessr_web/data/Schaefer2018_100Parcels_7Networks_order_FSLMNI152_1mm.nii.gz', json: '/neuroguessr_web/data/schaefer100.json', json_fr: '/neuroguessr_web/data/schaefer100_fr.json', name: 'Schaefer' },     
        'yeo7': { nii: '/neuroguessr_web/data/Yeo-7-liberal_space-MNI152NLin6_res-1x1x1.nii.gz', json: '/neuroguessr_web/data/yeo7.json', json_fr: '/neuroguessr_web/data/yeo7_fr.json', name: 'Yeo7' },
        'yeo17': { nii: '/neuroguessr_web/data/Yeo-17-liberal_space-MNI152NLin6_res-1x1x1.nii.gz', json: '/neuroguessr_web/data/yeo17.json', json_fr: '/neuroguessr_web/data/yeo17_fr.json', name: 'Yeo17' },
        'subcortical': { nii: '/neuroguessr_web/data/ICBM2009b_asym-SubCorSeg-1mm_nn_regrid.nii.gz', json: '/neuroguessr_web/data/subcortical.json', json_fr: '/neuroguessr_web/data/subcortical_fr.json', name: 'Subcortical' },
        'cerebellum': { nii: '/neuroguessr_web/data/Cerebellum-MNIfnirt-maxprob-thr25-1mm.nii.gz', json: '/neuroguessr_web/data/cerebellum.json', json_fr: '/neuroguessr_web/data/cerebellum_fr.json', name: 'Cerebellum' },
        'xtract': { nii: '/neuroguessr_web/data/xtract_web.nii.gz', json: '/neuroguessr_web/data/xtract_labels.json', json_fr: '/neuroguessr_web/data/xtract_labels_fr.json', name: 'White Matter'},
        'thalamus': { nii: '/neuroguessr_web/data/Thalamus_Nuclei-HCP-MaxProb.nii.gz', json: '/neuroguessr_web/data/thalamus7.json', json_fr: '/neuroguessr_web/data/thalamus7_fr.json', name: 'Thalamus'},
        'HippoAmyg': { nii: '/neuroguessr_web/data/HippoAmyg_web.nii.gz', json: '/neuroguessr_web/data/HippoAmyg_labels.json', json_fr: '/neuroguessr_web/data/HippoAmyg_labels_fr.json', name: 'Hippocampus & Amygdala' },
        'JHU': { nii: '/neuroguessr_web/data/JHU_web.nii.gz', json: '/neuroguessr_web/data/JHU_labels.json', json_fr: '/neuroguessr_web/data/JHU_labels_fr.json', name: 'JHU' },
        'territories' : { nii: '/neuroguessr_web/data/ArterialAtlas_stride.nii.gz', json: '/neuroguessr_web/data/artery_territories.json', json_fr: '/neuroguessr_web/data/artery_territories_fr.json', name: 'Territories' }
      };

      const selectedAtlasFiles = atlasFiles[atlas] || atlasFiles['aal'];

      async function fetchJSON(fnm) {
        try {
          const response = await fetch(fnm);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          return await response.json();
        } catch (e) {
          console.error(`Fetch failed for ${fnm}:`, e);
          throw new Error(`${e.message}`);
        }
      }

      async function loadAtlasData() {
        try {
          const lang = i18next.language;
          const jsonFile = lang === 'fr' && selectedAtlasFiles.json_fr ? selectedAtlasFiles.json_fr : selectedAtlasFiles.json;
          cmap = await fetchJSON(jsonFile);
          console.log(`Loaded atlas JSON (${jsonFile}):`, cmap);
          if (nv1 && nv1.volumes.length > 1) {
            nv1.volumes[1].setColormapLabel(cmap);
            const numRegions = Object.keys(cmap.labels).length;
            clut = new Uint8Array(numRegions * 4);

            if (atlas === 'aal') {
              clut[0] = Math.floor(Math.random() * 256);
              clut[1] = Math.floor(Math.random() * 256);
              clut[2] = Math.floor(Math.random() * 256);
              clut[3] = 255;
              clut[4] = Math.floor(Math.random() * 256);
              clut[5] = Math.floor(Math.random() * 256);
              clut[6] = Math.floor(Math.random() * 256);
              clut[7] = 255;
            } else if (atlas === 'glasser' || atlas === 'destrieux' || atlas === 'schaefer') {
              console.log('Atlas cmap.labels:', cmap.labels);
            } else {
              clut[0] = 0;
              clut[1] = 0;
              clut[2] = 0;
              clut[3] = 0;
              clut[4] = Math.floor(Math.random() * 256);
              clut[5] = Math.floor(Math.random() * 256);
              clut[6] = Math.floor(Math.random() * 256);
              clut[7] = 255;
            }

            for (let i = 2; i < numRegions; i++) {
              clut[i * 4 + 0] = Math.floor(Math.random() * 256);
              clut[i * 4 + 1] = Math.floor(Math.random() * 256);
              clut[i * 4 + 2] = Math.floor(Math.random() * 256);
              clut[i * 4 + 3] = 255;
            }

            nv1.volumes[1].colormapLabel.lut = clut.slice();
            nv1.setOpacity(1, 0.6);
            nv1.updateGLVolume();

            const atlasData = await nv1.volumes[1].getVolumeData();
            const dataRegions = [...new Set(atlasData.filter(val => val > 0).map(val => Math.round(val)))];
            validRegions = dataRegions.filter(val => cmap.labels[val] !== undefined && Number.isInteger(val));

            console.log(`Atlas: ${selectedAtlasFiles.name}`);
            console.log(`Atlas Data Sample:`, atlasData.slice(0, 10));
            console.log(`Data Regions (rounded):`, dataRegions);
            console.log(`Valid Regions:`, validRegions);
            console.log(`Valid Region Labels:`, validRegions.map(id => cmap.labels[id]));

            if (validRegions.length === 0) {
              console.error(`No valid regions found in ${selectedAtlasFiles.name} data.`);
              console.log(`cmap.labels keys:`, Object.keys(cmap.labels));
              validRegions = Object.keys(cmap.labels)
                .map(Number)
                .filter(val => val > 0 && Number.isInteger(val));
              if (validRegions.length === 0) {
                throw new Error(`No valid regions available for ${selectedAtlasFiles.name}`);
              }
              console.warn(`Fallback to cmap.labels keys:`, validRegions);
            }
          }
        } catch (error) {
          console.error(`Failed to load atlas data for ${selectedAtlasFiles.name}:`, error);
          targetText.textContent = i18next.t('error_loading_data', { atlas: selectedAtlasFiles.name });
        }
      }

      function updateGameDisplay() {
        scoreLabel.textContent = i18next.t('correct_label') + `: ${score}`;
        errorLabel.textContent = i18next.t('errors_label') + `: ${errors}`;
        streakLabel.textContent = i18next.t('streak_label') + `: ${streak}`;
        if (mode === 'navigation') {
          targetText.textContent = highlightedRegion 
            ? cmap.labels[highlightedRegion] || i18next.t('no_region_selected')
            : i18next.t('click_to_identify');
        } else if (currentTarget !== null && cmap && cmap.labels[currentTarget]) {
          const prefix = i18next.language === 'fr' ? 'Trouver : ' : 'Find: ';
          targetText.textContent = prefix + cmap.labels[currentTarget];
          console.log(`Displaying target: ${cmap.labels[currentTarget]} (ID: ${currentTarget})`);
        } else {
          targetText.textContent = i18next.t('not_started');
          console.log('No valid target or cmap.labels not loaded:', { currentTarget, cmap });
        }
      }

      async function initNiivue() {
        try {
          nv1 = new niivue.Niivue({
            show3Dcrosshair: true,
            backColor: [0, 0, 0, 1],
            crosshairColor: [1, 1, 1, 1]
          });
          await nv1.attachTo("gl1");
          nv1.setInterpolation(true);
          nv1.opts.crosshairGap = 0;
          nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS;
          nv1.opts.multiplanarForceRender = true;
          nv1.setSliceType(nv1.sliceTypeMultiplanar);
          nv1.opts.dragMode = nv1.dragModes.slicer3D;
          nv1.opts.yoke3Dto2DZoom = true;
          nv1.opts.isRadiologicalConvention = true;

          const volumeList1 = [
            { url: '/neuroguessr_web/data/mni152.nii.gz' },
            { url: selectedAtlasFiles.nii, isApplyScaling: false }
          ];
          await nv1.loadVolumes(volumeList1);

          await loadAtlasData();

          nv1.setClipPlane([2, 270, 0]);
          nv1.opts.isSliceMM = true;

          setupViewMenu();
          startGame();
        } catch (error) {
          console.error(`Failed to initialize Niivue for ${selectedAtlasFiles.name}:`, error);
          targetText.textContent = i18next.t('error_initializing');
        }
      }

      function toggleGroup(id) {
        let buttons = document.getElementsByClassName("viewBtn");
        let char0 = id.charAt(0);
        for (let i = 0; i < buttons.length; i++) {
          if (buttons[i].id.charAt(0) !== char0) continue;
          buttons[i].classList.remove("dropdown-item-checked");
          if (buttons[i].id === id)
            buttons[i].classList.add("dropdown-item-checked");
        }
      }

      function setupViewMenu() {
        async function onViewButtonClick(event) {
          event.preventDefault();
          if (event.target.id.charAt(0) === "|") {
            if (event.target.id === "|Axial") nv1.setSliceType(nv1.sliceTypeAxial);
            if (event.target.id === "|Coronal") nv1.setSliceType(nv1.sliceTypeCoronal);
            if (event.target.id === "|Sagittal") nv1.setSliceType(nv1.sliceTypeSagittal);
            if (event.target.id === "|Render") {
              nv1.setSliceType(nv1.sliceTypeRender);
              nv1.setClipPlane([2, 270, 0]);
            }
            if (event.target.id === "|MultiPlanar") {
              nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.NEVER;
              nv1.setSliceType(nv1.sliceTypeMultiplanar);
            }
            if (event.target.id === "|MultiPlanarRender") {
              nv1.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS;
              nv1.setSliceType(nv1.sliceTypeMultiplanar);
            }
            toggleGroup(event.target.id);
          }
          if (event.target.id === "Radiological") {
            nv1.opts.isRadiologicalConvention = !nv1.opts.isRadiologicalConvention;
            event.srcElement.classList.toggle("dropdown-item-checked");
            nv1.drawScene();
            return;
          }
          if (event.target.id === "ColoredAtlas") {
            const isChecked = event.srcElement.classList.contains("dropdown-item-checked");
            nv1.setOpacity(1, isChecked ? 0.0 : alphaSlider.value / 255);
            event.srcElement.classList.toggle("dropdown-item-checked");
            nv1.updateGLVolume();
            return;
          }
        }

        var buttons = document.getElementsByClassName("viewBtn");
        for (let i = 0; i < buttons.length; i++)
          buttons[i].addEventListener("click", onViewButtonClick, false);
      }

      function highlightTarget(isSuccess) {
        targetText.style.transition = 'all 0.1s ease-in-out';
        targetText.style.color = isSuccess ? '#4ade80' : '#f87171';
        targetText.style.fontWeight = 'bold';
        setTimeout(() => {
          targetText.style.color = '#d9dddc';
          targetText.style.transition = '';
        }, 200);
      }

      function resetGameState() {
        currentTarget = null;
        selectedVoxel = null;
        attempts = 0;
        usedRegions = [];
        highlightedRegion = null;
        targetText.textContent = mode === 'navigation' ? i18next.t('click_to_identify') : i18next.t('not_started');
        targetText.style.color = '#d9dddc';
        targetText.style.transition = '';
        guessButton.disabled = true;
        if (clut && nv1) {
          nv1.volumes[1].colormapLabel.lut = clut.slice();
          nv1.updateGLVolume();
        }
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        if (tooltip) {
          tooltip.remove();
          tooltip = null;
        }
      }

      function selectNewTarget() {
        if (validRegions.length === 0) {
          console.warn('No valid regions available for target selection');
          resetGameState();
          return;
        }
        if (mode === 'time-attack' && usedRegions.length === validRegions.length) {
          endTimeAttack();
          return;
        }
        let availableRegions = mode === 'time-attack' 
          ? validRegions.filter(r => !usedRegions.includes(r))
          : validRegions;
        if (availableRegions.length === 0) {
          console.warn('No available regions for target selection');
          resetGameState();
          return;
        }
        currentTarget = availableRegions[Math.floor(Math.random() * availableRegions.length)];
        if (mode === 'time-attack') {
          usedRegions.push(currentTarget);
        }
        if (cmap && cmap.labels[currentTarget]) {
          const prefix = i18next.language === 'fr' ? 'Trouver : ' : 'Find: ';
          targetText.textContent = prefix + cmap.labels[currentTarget];
          console.log(`Selected new target: ${cmap.labels[currentTarget]} (ID: ${currentTarget})`);
        } else {
          targetText.textContent = i18next.language === 'fr' ? 'Trouver : Inconnu' : 'Find: Unknown';
          console.error(`No label for currentTarget ${currentTarget}`, cmap);
        }
        targetText.style.color = '#d9dddc';
        targetText.style.transition = '';
        guessButton.disabled = true;
        attempts = 0;
        if (clut && nv1) {
          nv1.volumes[1].colormapLabel.lut = clut.slice();
          nv1.updateGLVolume();
        }
      }

      function highlightRegionFluorescentYellow(regionId) {
        if (mode === 'navigation' && regionId === 0) return;
        console.log('highlightRegionFluorescentYellow called with regionId:', regionId);
        if (clut && nv1 && regionId * 4 < clut.length) {
          const lut = clut.slice();
          for (let i = 3; i < lut.length; i += 4) {
            lut[i] = 0;
          }
          // lut[regionId * 4 + 0] = 255;
          // lut[regionId * 4 + 1] = 255;
          // lut[regionId * 4 + 2] = 0;
          lut[regionId * 4 + 3] = 255;
          nv1.volumes[1].colormapLabel.lut = lut;
          nv1.updateGLVolume();
          nv1.drawScene();
        } else {
          console.error('Cannot highlight region:', {
            clut: !!clut,
            nv1: !!nv1,
            regionId,
            lutLength: clut?.length
          });
        }
      }

      function highlightRegionOpacity(regionId) {
        if (clut && nv1 && regionId * 4 < clut.length) {
          const lut = clut.slice();
          for (let i = 0; i < lut.length / 4; i++) {
            if (i === regionId) {
              if (i === 0 && atlas !== 'aal' && atlas !== 'glasser' && atlas !== 'destrieux' && atlas !== 'schaefer') {
                lut[i * 4 + 3] = 0;
              } else {
                lut[i * 4 + 3] = Math.round(0.9 * 255);
              }
            } else if (highlightedRegion && i === highlightedRegion) {
              lut[i * 4 + 0] = 255;
              lut[i * 4 + 1] = 255;
              lut[i * 4 + 2] = 0;
              lut[i * 4 + 3] = 255;
            } else {
              if (i === 0 && atlas !== 'aal' && atlas !== 'glasser' && atlas !== 'destrieux' && atlas !== 'schaefer') {
                lut[i * 4 + 3] = 0;
              } else {
                lut[i * 4 + 3] = Math.round(0.6 * 255);
              }
            }
          }
          nv1.volumes[1].colormapLabel.lut = lut;
          nv1.updateGLVolume();
          nv1.drawScene();
        }
      }

      function startTimer() {
        startTime = Date.now();
        timeLabel.style.display = 'block';
        timerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
          const seconds = (elapsed % 60).toString().padStart(2, '0');
          timeLabel.textContent = i18next.t('time_label') + `: ${minutes}:${seconds}`;
        }, 1000);
      }

      function endTimeAttack() {
        clearInterval(timerInterval);
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const accuracy = ((score / (score + errors)) * 100).toFixed(2);
        targetText.textContent = i18next.t('game_over', { accuracy, minutes: Math.floor(elapsed / 60), seconds: elapsed % 60 });
        highlightTarget(true);
        setTimeout(() => {
          window.location.href = `index.html?score=${accuracy}&time=${elapsed}`;
        }, 2000);
      }

      function startGame() {
        gameRunning = true;
        score = 0;
        errors = 0;
        streak = 0;
        scoreLabel.textContent = i18next.t('correct_label') + ": 0";
        errorLabel.textContent = i18next.t('errors_label') + ": 0";
        streakLabel.textContent = i18next.t('streak_label') + ": 0";
        timeLabel.textContent = i18next.t('time_label') + ": 00:00";
        streakLabel.style.display = mode === 'streak' ? 'block' : 'none';
        timeLabel.style.display = mode === 'time-attack' ? 'block' : 'none';
        guessButton.style.display = mode === 'navigation' ? 'none' : 'inline-block';
        restoreColorButton.style.display = mode === 'navigation' ? 'inline-block' : 'none';
        scoreLabel.style.display = mode === 'navigation' ? 'none' : 'block';
        errorLabel.style.display = mode === 'navigation' ? 'none' : 'block';
        if (mode === 'time-attack') {
          startTimer();
        }
        if (mode === 'navigation') {
          targetText.textContent = i18next.t('click_to_identify');
        } else {
          selectNewTarget();
        }
      }

      function validateGuess() {
        if (!selectedVoxel || !gameRunning || !currentTarget) {
          console.warn('Cannot validate guess:', { selectedVoxel, gameRunning, currentTarget });
          return;
        }
        const clickedRegion = nv1.volumes[1].getValue(selectedVoxel[0], selectedVoxel[1], selectedVoxel[2]);
        const targetName = cmap && cmap.labels[currentTarget] ? cmap.labels[currentTarget] : `Region ${currentTarget} (Unknown)`;

        if (clickedRegion === currentTarget) {
          score++;
          scoreLabel.textContent = i18next.t('correct_label') + `: ${score}`;
          streak = mode === 'streak' ? streak + 1 : streak;
          streakLabel.textContent = i18next.t('streak_label') + `: ${streak}`;
          highlightTarget(true);
          attempts = 0;
          if (clut && nv1) {
            nv1.volumes[1].colormapLabel.lut = clut.slice();
            nv1.updateGLVolume();
          }
          selectNewTarget();
        } else {
          errors++;
          errorLabel.textContent = i18next.t('errors_label') + `: ${errors}`;
          if (mode === 'practice') {
            attempts++;
            const incorrectRegionName = cmap && cmap.labels[clickedRegion] ? cmap.labels[clickedRegion] : `Region ${clickedRegion} (Unknown)`;
            const prefix = i18next.language === 'fr' ? 'C\'est ' : 'It\'s ';
            targetText.textContent = prefix + incorrectRegionName + ' !';
            console.log(`Incorrect guess: ${incorrectRegionName} (ID: ${clickedRegion}), Expected: ${targetName} (ID: ${currentTarget})`);
            if (attempts >= 3) {
              highlightRegionFluorescentYellow(currentTarget);
            }
            setTimeout(() => {
              const findPrefix = i18next.language === 'fr' ? 'Trouver : ' : 'Find: ';
              targetText.textContent = findPrefix + targetName;
              targetText.style.color = '#d9dddc';
              targetText.style.transition = '';
            }, 2000);
          }
          highlightTarget(false);
          if (mode === 'streak') {
            targetText.textContent = i18next.t('streak_ended', { streak });
            highlightTarget(false);
            setTimeout(() => {
              window.location.href = `index.html?score=${streak}`;
            }, 1000);
            return;
          }
          selectedVoxel = null;
          guessButton.disabled = true;
        }
      }

      function createTooltip(text, x, y) {
        if (tooltip) {
          tooltip.remove();
        }
        tooltip = document.createElement('div');
        tooltip.className = 'region-tooltip';
        tooltip.textContent = text;
        tooltip.style.position = 'absolute';
        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
        document.body.appendChild(tooltip);
      }

      document.getElementById("gl1").addEventListener("mousemove", (e) => {
        if (!gameRunning || !nv1 || mode !== 'navigation' || highlightedRegion !== null) return;
        const pos = nv1.getNoPaddingNoBorderCanvasRelativeMousePosition(e, nv1.gl.canvas);
        const frac = nv1.canvasPos2frac([pos.x * nv1.uiData.dpr, pos.y * nv1.uiData.dpr]);
        if (frac[0] >= 0) {
          const mm = nv1.frac2mm(frac);
          const vox = nv1.volumes[1].mm2vox(mm);
          const idx = Math.round(nv1.volumes[1].getValue(vox[0], vox[1], vox[2]));
          if (isFinite(idx) && idx in cmap.labels) {
            createTooltip(cmap.labels[idx] || "Unknown", e.clientX, e.clientY);
          } else {
            if (tooltip) {
              tooltip.remove();
              tooltip = null;
            }
          }
        }
      });

      document.getElementById("gl1").addEventListener("mouseleave", () => {
        if (!gameRunning || !nv1 || mode !== 'navigation' || highlightedRegion !== null) return;
        if (tooltip) {
          tooltip.remove();
          tooltip = null;
        }
      });

      function handleCanvasInteraction(e) {
        if (!gameRunning || !nv1) return;
        e.preventDefault();
        const isTouch = e.type === 'touchstart';
        const touch = isTouch ? e.touches[0] : e;
        const pos = nv1.getNoPaddingNoBorderCanvasRelativeMousePosition({ clientX: touch.clientX, clientY: touch.clientY }, nv1.gl.canvas);
        const frac = nv1.canvasPos2frac([pos.x * nv1.uiData.dpr, pos.y * nv1.uiData.dpr]);
        if (frac[0] >= 0) {
          const mm = nv1.frac2mm(frac);
          const vox = nv1.volumes[1].mm2vox(mm);
          const idx = Math.round(nv1.volumes[1].getValue(vox[0], vox[1], vox[2]));
          if (isFinite(idx) && idx in cmap.labels) {
            selectedVoxel = vox;
            if (mode === 'navigation') {
              targetText.textContent = cmap.labels[idx] || i18next.t('no_region_selected');
              highlightedRegion = idx;
              highlightRegionFluorescentYellow(idx);
              if (tooltip) {
                tooltip.remove();
                tooltip = null;
              }
              nv1.opts.crosshairColor = [1, 1, 1, 1];
              nv1.drawScene();
            } else {
              guessButton.disabled = false;
              nv1.opts.crosshairColor = [1, 1, 1, 1];
              nv1.drawScene();
            }
            console.log(`Clicked voxel: ${vox}, Region ID: ${idx}, Region Name: ${cmap.labels[idx] || "Unknown"}`);
          } else {
            selectedVoxel = null;
            if (mode === 'navigation') {
              targetText.textContent = i18next.t('no_region_selected');
              highlightedRegion = null;
              if (clut && nv1) {
                nv1.volumes[1].colormapLabel.lut = clut.slice();
                nv1.updateGLVolume();
              }
            } else {
              guessButton.disabled = true;
            }
            console.log(`Clicked voxel: ${vox}, Invalid region ID: ${idx}`);
          }
        }
      }

      document.getElementById("gl1").addEventListener("click", handleCanvasInteraction);
      document.getElementById("gl1").addEventListener("touchstart", handleCanvasInteraction);

      document.addEventListener('keydown', (e) => {
        if (e.code === 'Escape' && gameRunning && mode === 'navigation') {
          e.preventDefault();
          if (clut && nv1) {
            nv1.volumes[1].colormapLabel.lut = clut.slice();
            nv1.updateGLVolume();
            nv1.drawScene();
          }
          targetText.textContent = i18next.t('click_to_identify');
          selectedVoxel = null;
          highlightedRegion = null;
        }
      });

      guessButton.onclick = validateGuess;

      initNiivue();
    </script>
  </body>
</html>